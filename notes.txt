NOTES:

-- Now --


-- later --
[ ] - Allow entering of coordinates via a vector or string to make setting up puzzles for testing quicker.
[ ] - Add in terminal GUI.


------- Complete -------
[Y] - Shut down threads when we found a thread with a solution.
[Y] - Update compilation instructions.
[Y] - Change test.cpp to main.cpp (kept test.cpp, made main.cpp)
[Y] - Say if using backtrack or recusrion in program start.
[Y] - Display num_steps
[Y] - Change partial fill to use the backtracking algo but somehow limited.
[Y] - Change names for increment decrement cell to indicate we are changing contents.
[Y] - Use matrix.Get/Set and Soduku.Get/Set correctly. In class use matrix only.
[Y] - set_const_cell needs info for it not being used for anything but unit tests.
[Y] - Fix upper and lower case diffirences.
[Y] - Add warning if trying to fill more than 9 cells to indicate solving could take a while.
[Y] - Fix description for solve_puzzle when taking away solve_Status.
[Y] - Change can_set description
[Y] - Prompt user for puzzle size.
[Y] - User defines size of sodoku puzzle
[Y] - Remove Attempted Cells
[Y] - Remove solve Status.
[Y] - Add test and fix for when the first cell is unset.
[Y] - Have display() output an input string.
[Y] - Have the tests run before the the main program.
[Y] - Use an "unset" var of -1
[Y] - When using display, display nothing for unset var's
[Y] - Impliment row + column check taking into account unset vars
[Y] - Fill in some cells by dividing size by filling in 15% with at least 1 cell.
[Y] - Add padding to display depending on if 1 digit ints or 2 digit ints.


LOC
Sodoku.cpp 	--------- 716
Sodoku.h ------------ 116
test.cpp ------------ 928
main.cpp ------------ 210
Square_Matrix.h ----- 78
Square_Matrix.cpp --- 315
-------------------------
			   Total: 2363


Why can I use optional paramaters only in .cpp and not .h?
Is there some sort of standard for accessors using capital letters?


------------------------------------------------------------
                   Example Output
VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
Running self tests ...
All tests passed (74 assertions in 17 test cases)

Size of Sodoku puzzle: 9

This is your empty sodoku puzzle.
| . . . . . . . . .  |
| . . . . . . . . .  |
| . . . . . . . . .  |
| . . . . . . . . .  |
| . . . . . . . . .  |
| . . . . . . . . .  |
| . . . . . . . . .  |
| . . . . . . . . .  |
| . . . . . . . . .  |

Lets fill 25% of it with some random yet valid starting cells.

         NOTE:
This partial fill does not guarantee to supply a valid puzzle.
So, this loop will try to find a solvable partially filled
puzzle by trying to actually solve it and if it can't solve
it, then it partially fills it again.
   Warning: If you set a large size(>7), this could take a while.

So far 50k steps have been taken, continue? [y/n]y
So far 500k steps have been taken, really continue? [y/n] n
Found an unsolvable puzzle, making a new one...
Found an unsolvable puzzle, making a new one...
Found an unsolvable puzzle, making a new one...
Found an unsolvable puzzle, making a new one...
So far 50k steps have been taken, continue? [y/n]y
So far 500k steps have been taken, really continue? [y/n] n
Found an unsolvable puzzle, making a new one...
So far 50k steps have been taken, continue? [y/n]y
So far 500k steps have been taken, really continue? [y/n] n
Found an unsolvable puzzle, making a new one...
Found an unsolvable puzzle, making a new one...
Found an unsolvable puzzle, making a new one...
Found an unsolvable puzzle, making a new one...
So far 50k steps have been taken, continue? [y/n]n
Found an unsolvable puzzle, making a new one...
Found an unsolvable puzzle, making a new one...
Found an unsolvable puzzle, making a new one...
Partially pre-filled puzzle.
| . . . . 1 . . . .  |
| . . 0 . . 5 . . .  |
| . . . . 6 . 5 . .  |
| . 1 . 7 . . . . .  |
| . 7 . . 3 . . 6 .  |
| 7 0 . 2 . 3 . . .  |
| . . . . 4 . . . .  |
| . 4 . . . 6 . . .  |
| 1 5 . . . . 2 . .  |

Solved puzzle
| 0 2 3 4 1 7 6 5 8  |
| 2 3 0 1 7 5 4 8 6  |
| 3 8 1 0 6 2 5 4 7  |
| 6 1 2 7 8 4 0 3 5  |
| 4 7 5 8 3 0 1 6 2  |
| 7 0 6 2 5 3 8 1 4  |
| 5 6 8 3 4 1 7 2 0  |
| 8 4 7 5 2 6 3 0 1  |
| 1 5 4 6 0 8 2 7 3  |

# of times a value was tried per cell.
|    1    3    4    5    0    8    7    6    9  |
|    3    4    0    2    8    0    5    9    7  |
|    4    9    2    1    0    3    0    5    8  |
|    7    0   23    0   89  255  401  644  566  |
|  305    0  666 1809    0 1461 2972    0 3063  |
|    0    0 2507    0 6816    0 6759 4272  775  |
|    6    7    9   14    0   12   28    3   11  |
|    9    0    8    6    3    0   14   11    2  |
|    0    0    5    7    1    9    0    8    4  |

Whew! That took 33680 steps!
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                   Example Output
------------------------------------------------------------




-----------------------------------------------
solve_puzzle uses backtrack with next_cell using a dash of recursion.




-----------------------------------------------
-- Solution! --
Recusively solve the matrix using backtrace!
auto_solve(void)
{
	solve(this)
}

sodoku solve_puzzle(sodoku&)
{	
	if(!valid)
	{
		Put in the next variable one int higher than current, 
		  going row member to row member 
		  next row member to row member.

		solve(this)
	}
	else
		return this
	

	Once we get here, it means the puzzle is solved!
}

// If the puzzle is not yet completed, try another node in the tree of
// possibilities.
/*if( !this->is_complete)
{

	Put in the next variable one int higher than current, 
	  going row member to row member 
	  next row member to row member.

	solve_puzzle(this)
}
else
	return this


Once we get here, it means the puzzle is solved!*/



-----------------------------------------------
GIVEN("A partially filled sodoku puzzle") {
	sodoku puzzle;
	puzzle.partial_fill(0.15);

	WHEN("trying to increment writable cell") {
		int x = 0;
		int y = 0;

		// Find a writable cell first.
		for (int row = 0; row < puzzle.Get_Size(); ++row)
			for (int column = 0; column < puzzle.Get_Size(); ++column)
				if (puzzle.can_)
				{
					/* code */
				}

		puzzle.increment_cell(0, 0);

		THEN("a few cells should be correctly filled") {
			puzzle.display();
			REQUIRE(puzzle.check_sodoku_validity());
		}
	}
}

(cell_contents == -1) ? (cell_contents = 1) : (cell_contents++);
this->matrix.Set_Elem(cell_contents, row, column);

SOLVE PUZZLE INCREMENT MUST TRY INCREMENTING MORE THAN ONCE!!!!


---------------------------
	// Starts on the top left of the puzzle to the top right, then down a row 
	// from left to right, and repeats to the end.
	for (int row = 0; row < this->matrix.Get_Size(); ++row)
		for (int column = 0; column < this->matrix.Get_Size(); ++column)
		{
			// If can't set that cell since it is a const cell, skip to the next cell.
			if (!this->can_set(column, row))
				continue;

			if (!this->try_to_fill(column, row))
			{
				// Go back in terms of coordinates.
				// If current node is at the first unit of a row, go up
				// a row and shift to the right most column.
				if (column == 0)
				{
					column = this->matrix.Get_Size();
					row--;
				}
				else
					column = column - 2;
			}
		}

	// If we reached here, then the all cells have been successfully set!
	return true;




	bool sodoku::try_to_fill(const int& column, const int& row){
	for (int i = 0; i <= this->matrix.Get_Size(); i++)
	{
		if (this->increment_cell(column, row)) // Can we increment the cell?
		{
			if (this->check_sodoku_validity()) // Is the new cell valid?
			{
				this->display();
				// If the new cell is valid then break out of trying to
				// increment the cell to a valid int.
				return true;
			}
		}
		// If the cell was incremented all the way and still a no go.
		else
		{
			// then change the cell back to default
			this->decrement_cell(column, row);

			return false;
		}
	}
